# 4. Objects and Functions

## 4.30 Objects and the Dot
*	Objects are collections of name/value pairs. How do these reside in the computer’s memory?
*	Objects can have primitive properties, object properties, or functions/methods.
*	Ways to set or access properties for `var person = new Object();`
 *	Computed Member Access: `person[‘firstname’] = ‘Tony’;`
  *	This is useful when you need to change what you are accessing. You can use a variable instead of a string, and thus change the variable to access different properties with the same command.
 *	Member Access: `person.firstname = ‘Tony’;`

## 4.31 Objects and Object Literals
*	An easier way to create a new object is `var person = {};`
*	You can also use this to set up new properties within the new object: 
 *	`var person = { firstname: ‘Tony’, lastname: ‘Alicea’ };`
*	Object literals are useful because you can create objects ‘on the fly’, e.g. when calling a function, you can create the object to pass as the parameter:
 *	`function greet(person) { console.log(‘Hi ‘ + person.firstname); }`
 *	We can then create a person to pass the function: 
 *	`greet({firstname: ‘Mary’, lastname: ‘Doe’ });`

## 4.32 Framework Aside: Faking Namespaces
*	a Namespace is a container for variables and functions. But Javascript doesn’t have them.
*	However, we can fake these using objects. e.g. we have `var greet = ‘Hello’;` and we also have `var greet = ‘Hola’; `. These will collide and override each other, so we can separate them using objects:
 *	`var english = {greet: ‘Hello’};`
 *	`var spanish = {greet: ‘Hola’};`
*	Now they no longer collide! This can be repeated

## 4.33 JSON and Object Literals
*	JSON looks a lot like object literal notation. XML was too slow, so JSON was developed, based on object literal notation in Javascript.
*	But there are differences. All JSON syntax is valid in Javascript, but not all JS object literal notation is valid in JSON. JSON is more strict. There must be quotes around the value names.
*	There are built-in functions in JS for dealing with JSON:
 *	`JSON.stringify(objectLiteral)` will turn a JS object literal into a JSON string.
 *	`JSON.parse(‘{ “firstname”: “Mary” }’);` will turn a JSON string into an object

## 4.34 Functions are Objects
*	First class functions: everything you can do with other types (strings, booleans etc.) you can do with functions. Javascript has them. They are powerful.
*	Functions are objects. They can have properties just like other objects - name/value pairs, objects, other functions. They have two important hidden properties:
 *	Name: functions can be anonymous, but they often have names.
 *	Code: this is a property of the function that is ‘invocable’ - it can be run. The code that you write in a function IS NOT the function. The code just happens to be one of the properties of the function
*	We can add properties to functions in the same way we would add them to other objects.
 *	FUNCTIONS ARE OBJECTS.

## 4.35 Function Statements and Function Expressions
*	Expression: a unit of code that results in a value. This value doesn’t have to save inside a variable.
*	Statement: a unit of code that merely does something without necessarily returning a value.
*	We can create a function that runs other functions like this: 
 *	`function run(a) { a(); } `
 *	` run(function() {console.log(‘hi’); }); ` //We then pass it another function as a parameter!

## 4.36 By Value vs By Reference
*	This is relevant when we make one thing equal another. See the code below:
		`var a = 20;`
		`var b = a; `
*	Here we have made b equal to a BY VALUE (because a is a primitive value). This means that Javascript creates a copy of that value in a different place in the memory, and then makes b equal to that. So b = 20. So we can change a without having any effect on b.
*	When dealing with functions and objects, however, this is different:
		`var c = {greeting: ‘hi’ };`
		`var d = c;`
		`c.greeting = ‘hello’;`
		`console.log(d.greeting); `//returns ‘hello’
*	Here we have made d equal to c BY REFERENCE (because c is an object), which means that Javascript does not create a copy. c and d simply both point to the same place in the memory, where this object is stored. This means that if we change something about c, then the same thing will have changed about d.
*	However, we can still change c to point to a different place without affecting d by pointing it to a new function that has not yet been created.
		`c = {name: ‘Owen’};`
*	Mutation: when things (like objects) are changed.
*	Side: why is b equal to a after we run `b = a`

## 4.37 Objects, Functions, and ‘this’
*	The execution phase focuses on the code portion of a function.
*	The javascript engine gives us an object called ‘this’ in ever execution context. However, ‘this’ points to different things in different circumstances.
 *	In the global object, ‘this’ points to the (global) Window object.
 *	In a function that is just invoked, ‘this’ still points towards to the global object.
 *	In a method that is in an object, ‘this’ points to the object that the function is in.
 *	However, in a function that is in an object but is not a method of that object (e.g. it is an internal function OF a method), ‘this’ points to the global object again. This is a problem
 *	To avoid it, we can use `var that = this` at the beginning of our method, and thereafter use that instead of this. Because they are equal to the same thing BY REFERENCE, so this will change if that is changed. We can also keep on using that in internal functions, because it doesn’t change.

## 4.38 Arrays - Collections of Anything
*	Javascript is dynamically typed, so arrays can hold values of any types. You can put objects or functions inside arrays together.

## 4.39 ‘arguments’ and spread
*	As well as the variable environment, outer environment, and ‘this’, Javascript also gives you ‘arguments’: a special keyword
*	It is important that you can invoke a function without passing it the parameters it expects. In this case it just sets the parameters to undefined and executes the code like that.
*	You can get around this with `parameter = parameter || ‘default’`
*	The arguments keyword is an array-like object that consists of all the parameters passed to a function, even the ones that it didn’t expect. It is not an array - it doesn’t have array methods.
*	‘spread’ is similar to array. You simply write …soemthing in the parameter space (with the other actual parameters and then use that as an array, which I think IS actually an array.

## 4.40 Framework Aside: Function Overloading
*	Function Overloading: when you have a function of the same name with different numbers of parameters. Javascript doesn’t have this. Instead, we must simply make another function that calls the first function but automatically passes one or more parameters, so there are fewer parameters to call in this second function because some of them are automatically passed.

## 4.41 Syntax Parsers
*	Important to think of the parser going through the code letter by letter and anticipating certain things based on what it is reading. If it sees something it doesn’t expect, it throws an error.

## 4.42 Dangerous Aside: Automatic Semicolon Insertion
*	Dangerous asides: places when it’s really easy to make a mistake and really hard to debug it once you have.
*	Anywhere the syntax THINKS a semicolon will be, it will put one. Sometimes this causes something completely different to what you want.
 *	So always watch when you use new lines, and always insert your own semicolons.

## 4.43 Framework Aside: Whitespace
*	We can use whitespace very liberally, e.g. to insert comments in between pretty much everything.


